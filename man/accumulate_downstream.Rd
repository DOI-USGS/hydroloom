% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/accumulate_downstream.R
\name{accumulate_downstream}
\alias{accumulate_downstream}
\alias{accumulate_downstream.data.frame}
\alias{accumulate_downstream.hy}
\title{Accumulate Variable Downstream}
\usage{
accumulate_downstream(x, var, main_path = NULL, total = FALSE, quiet = FALSE)

\method{accumulate_downstream}{data.frame}(x, var, main_path = NULL, total = FALSE, quiet = FALSE)

\method{accumulate_downstream}{hy}(x, var, main_path = NULL, total = FALSE, quiet = FALSE)
}
\arguments{
\item{x}{data.frame network compatible with \link{hydroloom_names}.}

\item{var}{variable to accumulate.}

\item{main_path}{character attribute name (required if total is TRUE.)
The attribute should contain a unique path identifier such as levelpath
or mainstem id. Used to avoid double counting accumulations through
systems of diversions. When a diversion derives from a main path it
will not be added back to the main path again when the diversion rejoins.}

\item{total}{logical if TRUE, accumulation will use "total" apportionment
if FALSE, divergence or dendritic apportionment will apply ( see details).}

\item{quiet}{logical quiet messages?}
}
\value{
vector of the same length as \code{nrow(x)} containing values of \code{var} accumulated downstream
}
\description{
given a variable, accumulate according to network topology.
}
\details{
Accumulation Methods:

Divergence apportioned (divergence routing): Where upstream values are passed with
fractional apportionment such that each downstream connection gets between
0 and 100 percent of the upstream value. This has also been referred to as
"divergence routing" Requires a "divergence_fraction" attribute and the
"total" parameter to be \code{FALSE}.

Dendritic apportionment (no divergence routing): Where upstream values are not passed to
secondary paths at all -- this is essentially a special case of divergence
apportioned where no diversion fraction value is provided and 0 is
assumed for all divergences. Do not include a "divergence_fraction" and
set "total" to \code{FALSE}.

No apportionment (total upstream): where upstream values are passed without being
apportioned such that each downstream connection gets the full upstream
value and there is special handling where diversions join back to the main
flow to avoid double counting. This is also referred to as
"total upstream routing". Set "total" to TRUE -- this method requires
a path attribute such as levelpath or mainstem identifier.
}
\examples{
x <- sf::read_sf(system.file("extdata/new_hope.gpkg", package = "hydroloom"))

# All default gives dendritic routing
x$dend_totdasqkm <- accumulate_downstream(add_toids(x), "AreaSqKM")
x$diff <- x$TotDASqKM - x$dend_totdasqkm

mapview::mapview(x, zcol = "diff")

# notice that diversions reset as if they were headwaters
plot(x['dend_totdasqkm'], lwd = x$dend_totdasqkm / 50)

# add a diversion_fraction that splits flow evenly
# max(dplyr::n()) is the number of flowlines in a FromNode group.
y <- x |>
  dplyr::group_by(FromNode) |>
  dplyr::mutate(divergence_fraction = 1 / max(dplyr::n())) |>
  dplyr::ungroup()

y$div_totdasqkm <- accumulate_downstream(y, "AreaSqKM")

# notice that diversions don't reset -- they carry a fraction of area
plot(y['div_totdasqkm'], lwd = y$div_totdasqkm  / 50)

z <- x |>
  dplyr::select(COMID, LevelPathI, FromNode, ToNode, Divergence, AreaSqKM, TotDASqKM)

z$tot_totdasqkm <- accumulate_downstream(z, "AreaSqKM", "LevelPathI", total = TRUE)

z$diff <- z$tot_totdasqkm - z$TotDASqKM

plot(z['tot_totdasqkm'], lwd = z$tot_totdasqkm  / 50)

mapview::mapview(z, zcol = "diff")
}
